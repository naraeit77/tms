import {
  pgTable,
  uuid,
  varchar,
  text,
  integer,
  bigint,
  numeric,
  boolean,
  timestamp,
  date,
  jsonb,
  index,
  unique,
} from 'drizzle-orm/pg-core';
import { sql } from 'drizzle-orm';
import { users } from './users';
import { oracleConnections } from './connections';
import { sqlStatistics } from './monitoring';

export const sqlTuningTasks = pgTable('sql_tuning_tasks', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  oracleConnectionId: uuid('oracle_connection_id').notNull().references(() => oracleConnections.id, { onDelete: 'cascade' }),
  sqlStatisticsId: uuid('sql_statistics_id').references(() => sqlStatistics.id, { onDelete: 'set null' }),
  sqlId: varchar('sql_id', { length: 13 }).notNull(),
  sqlText: text('sql_text').notNull(),
  title: varchar('title', { length: 255 }).notNull(),
  description: text('description'),
  priority: varchar('priority', { length: 20 }).default('MEDIUM'),
  status: varchar('status', { length: 20 }).default('IDENTIFIED'),
  assignedTo: uuid('assigned_to').references(() => users.id),
  assignedAt: timestamp('assigned_at', { withTimezone: true }),
  assignedBy: uuid('assigned_by').references(() => users.id),
  beforeElapsedTimeMs: bigint('before_elapsed_time_ms', { mode: 'number' }),
  beforeCpuTimeMs: bigint('before_cpu_time_ms', { mode: 'number' }),
  beforeBufferGets: bigint('before_buffer_gets', { mode: 'number' }),
  beforeDiskReads: bigint('before_disk_reads', { mode: 'number' }),
  beforeExecutions: integer('before_executions'),
  beforePlanHashValue: bigint('before_plan_hash_value', { mode: 'number' }),
  afterElapsedTimeMs: bigint('after_elapsed_time_ms', { mode: 'number' }),
  afterCpuTimeMs: bigint('after_cpu_time_ms', { mode: 'number' }),
  afterBufferGets: bigint('after_buffer_gets', { mode: 'number' }),
  afterDiskReads: bigint('after_disk_reads', { mode: 'number' }),
  afterExecutions: integer('after_executions'),
  afterPlanHashValue: bigint('after_plan_hash_value', { mode: 'number' }),
  improvementRate: numeric('improvement_rate', { precision: 5, scale: 2 }),
  elapsedTimeImprovedPct: numeric('elapsed_time_improved_pct', { precision: 5, scale: 2 }),
  bufferGetsImprovedPct: numeric('buffer_gets_improved_pct', { precision: 5, scale: 2 }),
  cpuTimeImprovedPct: numeric('cpu_time_improved_pct', { precision: 5, scale: 2 }),
  tuningMethod: varchar('tuning_method', { length: 100 }),
  tuningDetails: text('tuning_details'),
  implementedChanges: text('implemented_changes'),
  identifiedAt: timestamp('identified_at', { withTimezone: true }).defaultNow(),
  startedAt: timestamp('started_at', { withTimezone: true }),
  completedAt: timestamp('completed_at', { withTimezone: true }),
  cancelledAt: timestamp('cancelled_at', { withTimezone: true }),
  estimatedCompletionDate: date('estimated_completion_date'),
  reviewedBy: uuid('reviewed_by').references(() => users.id),
  reviewedAt: timestamp('reviewed_at', { withTimezone: true }),
  reviewComments: text('review_comments'),
  approvedBy: uuid('approved_by').references(() => users.id),
  approvedAt: timestamp('approved_at', { withTimezone: true }),
  tags: text('tags').array(),
  labels: jsonb('labels').default({}),
  metadata: jsonb('metadata').default({}),
  createdBy: uuid('created_by').references(() => users.id),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
}, (table) => [
  index('idx_sql_tuning_tasks_oracle_conn').on(table.oracleConnectionId),
  index('idx_sql_tuning_tasks_sql_id').on(table.sqlId),
  index('idx_sql_tuning_tasks_status').on(table.status),
  index('idx_sql_tuning_tasks_priority').on(table.priority),
  index('idx_sql_tuning_tasks_assigned').on(table.assignedTo),
  index('idx_sql_tuning_tasks_created').on(table.createdAt),
]);

export const tuningHistory = pgTable('tuning_history', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  tuningTaskId: uuid('tuning_task_id').notNull().references(() => sqlTuningTasks.id, { onDelete: 'cascade' }),
  oracleConnectionId: uuid('oracle_connection_id').notNull().references(() => oracleConnections.id, { onDelete: 'cascade' }),
  sqlId: varchar('sql_id', { length: 13 }).notNull(),
  activityType: varchar('activity_type', { length: 50 }).notNull(),
  description: text('description').notNull(),
  oldValue: jsonb('old_value'),
  newValue: jsonb('new_value'),
  elapsedTimeMs: bigint('elapsed_time_ms', { mode: 'number' }),
  bufferGets: bigint('buffer_gets', { mode: 'number' }),
  cpuTimeMs: bigint('cpu_time_ms', { mode: 'number' }),
  performedBy: uuid('performed_by').references(() => users.id),
  performedAt: timestamp('performed_at', { withTimezone: true }).defaultNow(),
  metadata: jsonb('metadata').default({}),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
}, (table) => [
  index('idx_tuning_history_task').on(table.tuningTaskId),
  index('idx_tuning_history_performed').on(table.performedAt),
  index('idx_tuning_history_type').on(table.activityType),
]);

export const tuningComments = pgTable('tuning_comments', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  tuningTaskId: uuid('tuning_task_id').notNull().references(() => sqlTuningTasks.id, { onDelete: 'cascade' }),
  parentCommentId: uuid('parent_comment_id'),
  comment: text('comment').notNull(),
  commentType: varchar('comment_type', { length: 20 }).default('COMMENT'),
  attachments: jsonb('attachments').default([]),
  authorId: uuid('author_id').notNull().references(() => users.id),
  authorName: varchar('author_name', { length: 100 }),
  mentions: uuid('mentions').array(),
  isResolved: boolean('is_resolved').default(false),
  resolvedBy: uuid('resolved_by').references(() => users.id),
  resolvedAt: timestamp('resolved_at', { withTimezone: true }),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
}, (table) => [
  index('idx_tuning_comments_task').on(table.tuningTaskId),
  index('idx_tuning_comments_parent').on(table.parentCommentId),
  index('idx_tuning_comments_author').on(table.authorId),
  index('idx_tuning_comments_created').on(table.createdAt),
]);

export const tuningRecommendations = pgTable('tuning_recommendations', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  tuningTaskId: uuid('tuning_task_id').references(() => sqlTuningTasks.id, { onDelete: 'cascade' }),
  oracleConnectionId: uuid('oracle_connection_id').notNull().references(() => oracleConnections.id, { onDelete: 'cascade' }),
  sqlId: varchar('sql_id', { length: 13 }).notNull(),
  recommendationType: varchar('recommendation_type', { length: 50 }).notNull(),
  title: varchar('title', { length: 255 }).notNull(),
  description: text('description'),
  rationale: text('rationale'),
  implementationSql: text('implementation_sql'),
  implementationSteps: text('implementation_steps').array(),
  estimatedEffort: varchar('estimated_effort', { length: 20 }),
  expectedImprovementPct: numeric('expected_improvement_pct', { precision: 5, scale: 2 }),
  expectedBenefit: text('expected_benefit'),
  potentialRisks: text('potential_risks'),
  priority: varchar('priority', { length: 20 }).default('MEDIUM'),
  status: varchar('status', { length: 20 }).default('PENDING'),
  isAutoGenerated: boolean('is_auto_generated').default(false),
  generatedBy: varchar('generated_by', { length: 50 }),
  decisionBy: uuid('decision_by').references(() => users.id),
  decisionAt: timestamp('decision_at', { withTimezone: true }),
  decisionNotes: text('decision_notes'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
}, (table) => [
  index('idx_tuning_recommendations_task').on(table.tuningTaskId),
  index('idx_tuning_recommendations_status').on(table.status),
  index('idx_tuning_recommendations_type').on(table.recommendationType),
  index('idx_tuning_recommendations_connection_created').on(table.oracleConnectionId, table.createdAt),
]);

export const planBaselines = pgTable('plan_baselines', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  oracleConnectionId: uuid('oracle_connection_id').notNull().references(() => oracleConnections.id, { onDelete: 'cascade' }),
  sqlId: varchar('sql_id', { length: 13 }).notNull(),
  planHashValue: bigint('plan_hash_value', { mode: 'number' }).notNull(),
  planName: varchar('plan_name', { length: 100 }).notNull().unique(),
  sqlHandle: varchar('sql_handle', { length: 100 }),
  isEnabled: boolean('is_enabled').default(true),
  isAccepted: boolean('is_accepted').default(true),
  isFixed: boolean('is_fixed').default(false),
  planTable: jsonb('plan_table').notNull(),
  cost: numeric('cost'),
  executions: integer('executions').default(0),
  avgElapsedTimeMs: numeric('avg_elapsed_time_ms', { precision: 12, scale: 2 }),
  avgBufferGets: numeric('avg_buffer_gets', { precision: 12, scale: 2 }),
  createdInOracleAt: timestamp('created_in_oracle_at', { withTimezone: true }),
  lastModifiedAt: timestamp('last_modified_at', { withTimezone: true }),
  createdBy: uuid('created_by').references(() => users.id),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
}, (table) => [
  unique('uq_plan_baselines').on(table.oracleConnectionId, table.sqlId, table.planHashValue),
  index('idx_plan_baselines_oracle_conn').on(table.oracleConnectionId),
  index('idx_plan_baselines_sql_id').on(table.sqlId),
  index('idx_plan_baselines_enabled').on(table.isEnabled),
]);

export const tuningReports = pgTable('tuning_reports', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  reportType: varchar('report_type', { length: 50 }).notNull(),
  title: varchar('title', { length: 255 }).notNull(),
  startDate: date('start_date').notNull(),
  endDate: date('end_date').notNull(),
  summary: jsonb('summary'),
  content: jsonb('content'),
  format: varchar('format', { length: 20 }).default('HTML'),
  oracleConnectionId: uuid('oracle_connection_id').references(() => oracleConnections.id),
  filters: jsonb('filters').default({}),
  generatedBy: uuid('generated_by').references(() => users.id),
  generatedAt: timestamp('generated_at', { withTimezone: true }).defaultNow(),
  generationTimeMs: integer('generation_time_ms'),
  recipients: jsonb('recipients').default([]),
  sentAt: timestamp('sent_at', { withTimezone: true }),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
}, (table) => [
  index('idx_tuning_reports_type').on(table.reportType),
  index('idx_tuning_reports_period').on(table.startDate, table.endDate),
  index('idx_tuning_reports_generated').on(table.generatedAt),
]);
