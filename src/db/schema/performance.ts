import {
  pgTable,
  uuid,
  varchar,
  text,
  integer,
  bigint,
  numeric,
  smallint,
  boolean,
  timestamp,
  date,
  jsonb,
  char,
  index,
  unique,
} from 'drizzle-orm/pg-core';
import { sql } from 'drizzle-orm';
import { oracleConnections } from './connections';

export const sqlPerformanceHistory = pgTable('sql_performance_history', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  oracleConnectionId: uuid('oracle_connection_id').notNull().references(() => oracleConnections.id, { onDelete: 'cascade' }),
  sqlId: varchar('sql_id', { length: 13 }).notNull(),
  planHashValue: bigint('plan_hash_value', { mode: 'number' }),
  parsingSchemaName: varchar('parsing_schema_name', { length: 128 }),
  module: varchar('module', { length: 64 }),
  action: varchar('action', { length: 64 }),
  sqlText: text('sql_text'),
  executions: integer('executions').default(0),
  elapsedTimeMs: numeric('elapsed_time_ms', { precision: 12, scale: 2 }).default('0'),
  cpuTimeMs: numeric('cpu_time_ms', { precision: 12, scale: 2 }).default('0'),
  bufferGets: integer('buffer_gets').default(0),
  diskReads: integer('disk_reads').default(0),
  rowsProcessed: bigint('rows_processed', { mode: 'number' }).default(0),
  physicalReadRequests: integer('physical_read_requests').default(0),
  physicalWriteRequests: integer('physical_write_requests').default(0),
  directReads: integer('direct_reads').default(0),
  directWrites: integer('direct_writes').default(0),
  applicationWaitTimeMs: numeric('application_wait_time_ms', { precision: 10, scale: 2 }).default('0'),
  concurrencyWaitTimeMs: numeric('concurrency_wait_time_ms', { precision: 10, scale: 2 }).default('0'),
  clusterWaitTimeMs: numeric('cluster_wait_time_ms', { precision: 10, scale: 2 }).default('0'),
  userIoWaitTimeMs: numeric('user_io_wait_time_ms', { precision: 10, scale: 2 }).default('0'),
  performanceGrade: char('performance_grade', { length: 1 }),
  source: varchar('source', { length: 20 }).notNull(),
  collectedAt: timestamp('collected_at', { withTimezone: true }).notNull().defaultNow(),
  collectionHour: smallint('collection_hour'),
  collectionDate: date('collection_date'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
}, (table) => [
  index('idx_perf_history_conn_date').on(table.oracleConnectionId, table.collectionDate, table.collectedAt),
  index('idx_perf_history_conn_datetime').on(table.oracleConnectionId, table.collectedAt),
  index('idx_perf_history_sql_id').on(table.oracleConnectionId, table.sqlId, table.collectedAt),
  index('idx_perf_history_grade').on(table.oracleConnectionId, table.collectionDate, table.performanceGrade),
  index('idx_perf_history_elapsed').on(table.oracleConnectionId, table.collectionDate, table.elapsedTimeMs),
  index('idx_perf_history_schema').on(table.oracleConnectionId, table.parsingSchemaName, table.collectionDate),
]);

export const sqlPerformanceDailySummary = pgTable('sql_performance_daily_summary', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  oracleConnectionId: uuid('oracle_connection_id').notNull().references(() => oracleConnections.id, { onDelete: 'cascade' }),
  summaryDate: date('summary_date').notNull(),
  totalSqls: integer('total_sqls').default(0),
  totalExecutions: bigint('total_executions', { mode: 'number' }).default(0),
  avgElapsedTimeMs: numeric('avg_elapsed_time_ms', { precision: 12, scale: 2 }).default('0'),
  avgCpuTimeMs: numeric('avg_cpu_time_ms', { precision: 12, scale: 2 }).default('0'),
  avgBufferGets: numeric('avg_buffer_gets', { precision: 12, scale: 2 }).default('0'),
  avgDiskReads: numeric('avg_disk_reads', { precision: 12, scale: 2 }).default('0'),
  maxElapsedTimeMs: numeric('max_elapsed_time_ms', { precision: 12, scale: 2 }).default('0'),
  maxBufferGets: integer('max_buffer_gets').default(0),
  gradeACount: integer('grade_a_count').default(0),
  gradeBCount: integer('grade_b_count').default(0),
  gradeCCount: integer('grade_c_count').default(0),
  gradeDCount: integer('grade_d_count').default(0),
  gradeFCount: integer('grade_f_count').default(0),
  peakHour: smallint('peak_hour'),
  peakHourExecutions: integer('peak_hour_executions'),
  collectionCount: integer('collection_count').default(0),
  firstCollectionAt: timestamp('first_collection_at', { withTimezone: true }),
  lastCollectionAt: timestamp('last_collection_at', { withTimezone: true }),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
}, (table) => [
  unique('uq_daily_summary').on(table.oracleConnectionId, table.summaryDate),
  index('idx_daily_summary_conn_date').on(table.oracleConnectionId, table.summaryDate),
]);

export const performanceCollectionSettings = pgTable('performance_collection_settings', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  oracleConnectionId: uuid('oracle_connection_id').notNull().unique().references(() => oracleConnections.id, { onDelete: 'cascade' }),
  isEnabled: boolean('is_enabled').default(true),
  collectionIntervalMinutes: integer('collection_interval_minutes').default(10),
  retentionDays: integer('retention_days').default(30),
  minExecutions: integer('min_executions').default(1),
  minElapsedTimeMs: numeric('min_elapsed_time_ms', { precision: 10, scale: 2 }).default('0'),
  excludedSchemas: text('excluded_schemas').array().default(sql`ARRAY['SYS','SYSTEM','DBSNMP','SYSMAN','OUTLN','MDSYS','ORDSYS','EXFSYS','WMSYS','CTXSYS','XDB']`),
  topSqlLimit: integer('top_sql_limit').default(500),
  collectAllHours: boolean('collect_all_hours').default(true),
  collectStartHour: smallint('collect_start_hour').default(0),
  collectEndHour: smallint('collect_end_hour').default(23),
  lastCollectionAt: timestamp('last_collection_at', { withTimezone: true }),
  lastCollectionStatus: varchar('last_collection_status', { length: 20 }),
  lastCollectionCount: integer('last_collection_count').default(0),
  lastErrorMessage: text('last_error_message'),
  totalCollections: integer('total_collections').default(0),
  successfulCollections: integer('successful_collections').default(0),
  failedCollections: integer('failed_collections').default(0),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
});

export const performanceCollectionLogs = pgTable('performance_collection_logs', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  oracleConnectionId: uuid('oracle_connection_id').notNull().references(() => oracleConnections.id, { onDelete: 'cascade' }),
  startedAt: timestamp('started_at', { withTimezone: true }).notNull().defaultNow(),
  completedAt: timestamp('completed_at', { withTimezone: true }),
  durationMs: integer('duration_ms'),
  status: varchar('status', { length: 20 }).notNull(),
  recordsCollected: integer('records_collected').default(0),
  recordsInserted: integer('records_inserted').default(0),
  recordsUpdated: integer('records_updated').default(0),
  source: varchar('source', { length: 20 }).notNull(),
  errorMessage: text('error_message'),
  errorDetails: jsonb('error_details'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
}, (table) => [
  index('idx_collection_logs_recent').on(table.oracleConnectionId, table.startedAt),
]);
